Алгоритм <<Сортировки вставкой>> предназначен для решения задачи сортировки.

Input: Последовательность n чисел $a_1, a_2, ... , a_n$

Output: Входная последовательность в неубывающем порядке.

Алгоритм эффективно работает при сортировке небольшого количества элементов.
Аналогом алгоритма сортировки вставкой является способ сортировки карт. В начальный момент
в руке нет карт. Затем из колоды карта, которая будет наименьшая (т.к. меньше её уже нет). Затем ещё одна, которая должна встать справа от первой карты, если она больше и слева - иначе. Далее процесс повторяется и карта помещается в нужное место. Чтобы определить куда нужно вставлять карту её масть и достоинства сравниваются с другими картами, например, справа налево. В любой момент времени карты будут отсортированы.
Алгоритм сортирует входные данные на месте, без привлечения дополнительной памяти: перестановка чисел выполняется в пределах сортируемого массива, и объём используемой при этом дополнительной памяти в любой момент времени не превышает некоторую постоянную величину.

Инварианты цикла и корректность сортировки вставкой.

В начале каждой итерации цикла for сортируемый массив А  состоит из двух частей А[0, j-1] и A[j, A.size()-1]. Элементы А[0, j-1] отсортированы, а элементы A[j, A.size()-1], пока нет.

Инвариант цикла (loop invariant):

В начале каждой итерации цикла for, подмассив A[0, j-1], состоит из элементов, которые изначально находились в A[0, j-1], но теперь расположены в отсортированном порядке. 

Инварианты цикла позволяют понять, корректно ли работает алгоритм. Необходимо показать, что инварианты циклов обладают следующими свойствами.

**Инициализация.** Они справедливы перед первой итерацией цикла.<br/>
**Сохранение.** Если они истинны перед очередной итерацией цикла, то они остаются истинны и после неё.<br/>
**Завершение.** По завершении цикла инварианты позволяют убедиться в правильности алгоритма.<br/>

Рассмотрим, соблюдение этих свой.

**Инициализация.** Покажем справедливость инварианта цикла перед первой итерацией, т.е. при i = 1. (Если рассматривается цикл for, момент времени, когда проверяется справедливость инварианта цикла перед первой итерацией, наступает сразу после начального присваивания значения индексу цикла, непосредственно перед первой проверкой в заголовчной инструкции цикла. В процедуре InsertionSort это момент, когда i присваивается значение 2, но ещё не выполнена проверка i < vectorSize). Таким образом массив А состоит только из одного элемента А[0], и он отсортирован. Таким образом, инвариант цикла выполняется перед первой итерацией цикла.<br/>
**Сохранение.** Покажем, что инвариант цикла сохраняется после каждой итерации. Предположим, что подмассив A[0,i-1] - отсортирован. Тогда на i-ой итерации мы идём по отсортированному массиву (в цикле while) и ищем место, где A[i] будет меньше A[j] или пока не дойдём до начала массива. Таким образом мы получим отсортированный подмассив A[0, i].<br/>
**Завершение** Рассмотрим, что происходит при завершении работы цикла. Условие приводящие к завершению работы цикла for: i >= A.size(). В этом случае i = A.size(). Подставив в формулировку инварианта вместо j значение i, получим массив A[0, i-1], который находится в рассортированном порядке, но после выполнения цикла for получили отсортированный массив A[0, i-1], который является исходным массивом. Таким образом получен отсортированный массив, следовательно, алгоритм корректен.
